\section{An Abstract Presentation of Mining}\label{sec:mining}

Different mining algorithms can be presented
inside the uniform setting of a competitive game
played, concurrently and independently, by each peer of a blockchain network, with the
goal to choose which peer wins the right to create and add the \textbf{next}
block to the stable chain. This \textbf{next} must be \emph{valid}, that is, respect
all consensus rules. For instance,
it must point back to an existing block and
include transactions with valid signatures
(the full list of consensus rules is large and outside the topic of this paper).
The mining game works in terms of:
%
\begin{itemize}
\item \emph{challenge}: from the current chain $\xi$,
  compute, deterministically, a challenge for \textbf{next};
\item \emph{answer}: create, if possible,
  a \textbf{next} that satisfies the challenge;
\item \emph{competition}: among more possible \textbf{next}s, prefer the \emph{best}
  one \wrt{} some notion of chain quality.
\end{itemize}
%
Each peer performs this mining algorithm,
whispers its resulting \textbf{next} block to its
connected peers and receives the \textbf{next} block of its connected peers. In case
of more alternatives for \textbf{next}, the competition rule is used to choose the
emerging winner. This gives rise to a \emph{consensus algorithm} that uses the mining
algorithm as a subroutine.

For proof of work, the mining game becomes:
%
\begin{itemize}
\item \emph{challenge}: compute an integer $\difficulty$ from $\xi$
  and find a valid \textbf{next} such that $\hash(\mathbf{next})\ge\difficulty$;
\item \emph{answer}: create a \textbf{next} by rotating the possible
  values for its nonce field, until $\hash(\mathbf{next})\ge\difficulty$;
\item among more possible \textbf{next}s, prefer that with the largest hash.
\end{itemize}
%
The computation of $\difficulty$ is not relevant here.
Moreover, Bitcoin's proof of work is usually given
in terms of a \emph{smallest} hash, but we require (equivalently) the
\emph{largest} hash to match the intuition that a higher $\difficulty$ makes mining harder.

For proof of stake, it is generally accepted that there is
\emph{no} mining~\cite{Kwon14}, but a mining game can be defined also in this case:
%
\begin{itemize}
\item \emph{challenge}: compute an integer $i$ from $\xi$ (the index of the chosen
  validator);
\item \emph{answer}: if this algorithm is run by the $i$th validator,
  create a valid \textbf{next} block; otherwise, do not create any \textbf{next} and
  wait to receive one;
\item among more possible \textbf{next}s, choose any of them, since
  the choice is irrelevant for what mining is concerned.
\end{itemize}
%
The algorithm for computing $i$ is irrelevat here: often, it is a simple
round-robin. Moreover, the consensus algorithm typically enriches the above
mining algorithm with a Byzantine protocol of pre-votes and pre-commits~\cite{Kwon14}.

Finally, proof of space, as presented in~\cite{Spoto25},
is based on the idea that \textbf{next} must contain
a data structure, called \emph{nonce}, that can be quickly recovered from a
set of precomputed nonces on disk (the \emph{plot file}). The mining game in this case is:
%
\begin{itemize}
\item \emph{challenge}: compute some data $\kappa$ from $\xi$;
\item \emph{answer}: create a valid \textbf{next} block, containing a nonce $\nu$
  derived from the plot file and from $\kappa$;
\item among more possible \textbf{next}s, choose that with the smallest
  $\delay(\nu,\kappa)$, where $\nu$ is the nonce in \textbf{next}.
\end{itemize}
%
The algorithm for computing $\kappa$ is irrelevant here. In any case,
$\kappa$ is used to select a nonce, from the plot file, that minimizes
$\delay$. The key point of this proof of space algorithm
is that the computation of the nonces (\ie{}, of the plot file) is so expensive
that it cannot be done on-the-fly, for each mined block, but they must be computed
once and for all, before starting mining, and kept on disk to answer, quickly, the mining
challenges. The consensus algorithm uses $\delay$ to wait until the block becomes valid.

This abstract presentation of mining makes it clear
that mining is a subroutine whose input is the challenge derived from the current
chain $\xi$ and whose output is the answer \ie{}, the information
needed to create \textbf{next}:
a nonce for proof of work and proof of space (although a different notion of nonce is
used in either case), and a Boolean for proof of stake
(create the block or rather let another validator do it).
This is shown in Fig.~\ref{fig:local_mining}, where
the miner that provides the answer to create \textbf{next}
and the peer that actually creates \textbf{next}
are distinct software parts of the same tool, working in the same machine.

\begin{figure}[t]
  \begin{center}
    \begin{tikzpicture}
      \draw [fill=VioletRed,thick] (0,0) rectangle +(3,1.5);
      \draw (1.5,0.75) node {{\scriptsize bockchain peer}};

      \draw [fill=lightred,thick] (5,0.35) rectangle +(2,0.8);
      \draw (6.0,0.75) node {{\scriptsize local miner}};

      \draw[->, thick] (3,1.0) -- (5,1.0);
      \draw (4.0,1.2) node {{\scriptsize challenges}};

      \draw[<-, thick] (3,0.5) -- (5,0.5);
      \draw (4.0,0.25) node {{\scriptsize answers}};

    \end{tikzpicture}
  \end{center}
  \caption{Peer and local miner as separate software parts in the same machine.}\label{fig:local_mining}
\end{figure}

