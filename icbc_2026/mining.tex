\section{An Abstract Presentation of Mining}\label{sec:mining}

Different mining algorithms fit
inside the uniform setting of a competitive game
played, concurrently and independently, by the peers of a blockchain network, whose
goal is to decide which peer may add a \emph{valid} \textbf{next}
block to the stable chain. \emph{Valid} means that it respects
all consensus rules. For instance,
it points back to an existing block and
includes transactions with valid signatures
(the full, large list of consensus rules is outside the topic of this paper).
The game works in terms of:
%
\begin{itemize}
\item \emph{challenge}: from the current chain $\xi$,
  compute, deterministically, a challenge for \textbf{next};
\item \emph{answer}: create, if possible,
  a \textbf{next} that satisfies the challenge;
\item \emph{competition}: among more possible \textbf{next}s, prefer the \emph{best}
  one \wrt{} some notion of chain quality.
\end{itemize}
%
Each peer runs this mining algorithm,
whispers its resulting \textbf{next} to its
connected peers and receives the \textbf{next} of its connected peers. In case
of more alternative \textbf{next}s, the competition rule lets one choose the
winner. This gives rise to a \emph{consensus algorithm} that uses the mining
algorithm as a subroutine.

For proof of work, the mining game becomes:
%
\begin{itemize}
\item \emph{challenge}: compute an integer $\difficulty$ from $\xi$
  and find a valid \textbf{next} such that $\hash(\mathbf{next})\ge\difficulty$;
\item \emph{answer}: create a \textbf{next} by rotating the possible
  values for its nonce field, until $\hash(\mathbf{next})\ge\difficulty$;
\item among more \textbf{next}s, prefer that with the largest hash.
\end{itemize}
%
The computation of $\difficulty$ is not relevant here.
Moreover, Bitcoin's proof of work is usually given
in terms of a \emph{smallest} hash, but we require (equivalently) the
\emph{largest} hash to match the intuition that a higher $\difficulty$ makes mining harder.

For proof of stake, it is generally accepted that there is
\emph{no} mining~\cite{Kwon14}, but a mining game can be defined also in this case:
%
\begin{itemize}
\item \emph{challenge}: compute an integer $i$ from $\xi$ (the index of the chosen
  validator);
\item \emph{answer}: the $i$th validator
  creates a valid \textbf{next}; the others do not create anything and
  wait to receive \textbf{next};
\item among more possible \textbf{next}s, choose any of them, since
  this should not occur for this mining algorithm.
\end{itemize}
%
The algorithm for computing $i$ is irrelevat here: often, it is a simple
round-robin. Moreover, the consensus algorithm typically enriches the above
mining algorithm with a Byzantine protocol of pre-votes and pre-commits~\cite{Kwon14}.

Finally, proof of space, as presented in~\cite{Spoto25},
is based on the idea that \textbf{next} must contain
a data structure, called \emph{nonce}, that can be quickly recovered from a
set of precomputed nonces on disk (the \emph{plot file}). The mining game in this case is:
%
\begin{itemize}
\item \emph{challenge}: compute some data $\kappa$ from $\xi$;
\item \emph{answer}: create a valid \textbf{next} block, containing a nonce $\nu$
  derived from the plot file and from $\kappa$;
\item among more possible \textbf{next}s, choose that with the smallest
  $\delay(\nu,\kappa)$, where $\nu$ is the nonce in \textbf{next}.
\end{itemize}
%
The computation of $\kappa$ is irrelevant here. In any case,
$\kappa$ is used to select a nonce, from the plot file, that minimizes
$\delay$. The key point of this mining algorithm
is that the computation of the nonces (\ie{}, of the plot file) is so expensive
that it cannot be done on-the-fly, for each mined block, but rather
once and for all, before starting mining. The plot remains on disk to answer, quickly, mining
challenges. The consensus algorithm uses $\delay$ to wait until the block becomes valid.

This abstract presentation of mining clarifies
that mining is a subroutine whose input is the challenge derived from the current
chain $\xi$ and whose output is the answer \ie{}, the information
needed to create \textbf{next}:
a nonce for proof of work and proof of space (although a different notion of nonce is
used in either case), and a Boolean for proof of stake
(create the block or rather let another validator do it).
Fig.~\ref{fig:local_mining} shows this:
the miner that provides the answer to create \textbf{next}
and the peer that actually creates \textbf{next}
are separate software parts of the same tool, working in the same machine.

\begin{figure}[t]
  \begin{center}
    \begin{tikzpicture}
      \draw [fill=VioletRed,thick] (0,0) rectangle +(3,1.5);
      \draw (1.5,0.75) node {{\scriptsize bockchain peer}};

      \draw [fill=lightred,thick] (5,0.35) rectangle +(2,0.8);
      \draw (6.0,0.75) node {{\scriptsize local miner}};

      \draw[->, thick] (3,1.0) -- (5,1.0);
      \draw (4.0,1.2) node {{\scriptsize challenges}};

      \draw[<-, thick] (3,0.5) -- (5,0.5);
      \draw (4.0,0.25) node {{\scriptsize answers}};

    \end{tikzpicture}
  \end{center}
  \caption{Peer and local miner as separate software parts in the same machine.}\label{fig:local_mining}
\end{figure}

